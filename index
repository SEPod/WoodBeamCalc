<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wood Beams – The World’s Slowest Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #f5f5f7;
      --card-bg: #ffffff;
      --border: #d0d0d5;
      --accent: #1f6feb;
      --accent-soft: rgba(31, 111, 235, 0.08);
      --text-main: #111827;
      --text-muted: #4b5563;
      --danger: #b91c1c;
      --radius-lg: 16px;
      --radius-md: 10px;
      --shadow-soft: 0 14px 30px rgba(15, 23, 42, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #e5edff 0, #f5f5f7 55%);
      color: var(--text-main);
    }

    .app {
      max-width: 980px;
      margin: 0 auto;
      padding: 2.5rem 1rem 3rem;
    }

    header {
      margin-bottom: 1.75rem;
      text-align: left;
    }

    header h1 {
      margin: 0 0 0.35rem;
      font-size: 1.9rem;
      letter-spacing: 0.03em;
    }

    .tagline {
      margin: 0 0 0.35rem;
      font-size: 0.98rem;
      font-weight: 600;
      color: #f59e0b;
    }

    header p {
      margin: 0;
      color: var(--text-muted);
      max-width: 720px;
      font-size: 0.95rem;
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft);
      padding: 1.4rem 1.5rem 1.7rem;
      margin-bottom: 1.4rem;
      border: 1px solid rgba(148,163,184,0.3);
    }

    .card h2 {
      margin: 0 0 0.7rem;
      font-size: 1.2rem;
    }

    .card h3 {
      margin: 0.3rem 0 0.3rem;
      font-size: 1.0rem;
    }

    .sub {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin: 0 0 0.6rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 0.6rem 1rem;
      margin-top: 0.4rem;
    }

    .field {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
    }

    .field label {
      margin-bottom: 0.14rem;
      color: var(--text-muted);
    }

    .field input,
    .field select {
      padding: 0.35rem 0.45rem;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      font-size: 0.85rem;
    }

    .field input:focus,
    .field select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
      background: #ffffff;
    }

    .inline-radio {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-size: 0.8rem;
      margin-top: 0.3rem;
      color: var(--text-muted);
    }

    .inline-radio label {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      cursor: pointer;
    }

    .eq-block {
      border-radius: var(--radius-md);
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(255,255,255,0.9);
      padding: 0.75rem 0.9rem;
      margin-top: 0.7rem;
      font-size: 0.85rem;
    }

    .eq-options {
      margin-top: 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .eq-options label {
      display: flex;
      align-items: flex-start;
      gap: 0.35rem;
      cursor: pointer;
    }

    .eq-options code {
      font-size: 0.8rem;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.65rem;
      margin-top: 0.9rem;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 0.55rem 1.15rem;
      font-size: 0.92rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      white-space: nowrap;
    }

    button.primary {
      background: var(--accent);
      color: #ffffff;
      box-shadow: 0 10px 18px rgba(31,111,235,0.35);
    }

    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .mono-block {
      width: 100%;
      min-height: 180px;
      font-family: "SF Mono", ui-monospace, Menlo, Consolas, monospace;
      font-size: 0.82rem;
      line-height: 1.45;
      padding: 0.75rem 0.9rem;
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      background: #0f172a;
      color: #e5e7eb;
      box-shadow: inset 0 0 0 1px rgba(15,23,42,0.8);
      overflow-x: auto;
      white-space: pre;
    }

    .mono-block.small {
      min-height: 120px;
      margin-top: 0.5rem;
    }

    .copy-status {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 0.35rem;
      min-height: 1em;
    }

    .copy-status.success { color: #059669; }
    .copy-status.error { color: var(--danger); }

    footer {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      text-align: right;
    }

    @media (max-width: 640px) {
      .app { padding-inline: 0.8rem; }
      header h1 { font-size: 1.6rem; }
      button.primary,
      button.secondary {
        flex: 1 1 auto;
        justify-content: center;
      }
      .mono-block {
        min-height: 160px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Wood Beams</h1>
      <p class="tagline">The world’s slowest calculator and fastest learning tool.</p>
      <p>
        Simple-span wood beam trainer. Enter geometry and loads, then earn your answer by picking the
        correct internal force equations first.
      </p>
    </header>

    <!-- 1: GEOMETRY & MATERIAL -->
    <section class="card">
      <h2>1. Geometry &amp; material</h2>
      <p class="sub">Basic span and design settings. Units are up to you, just stay consistent.</p>
      <div class="grid">
        <div class="field">
          <label for="L">Span length, L</label>
          <input id="L" type="number" step="0.01" placeholder="e.g. 16 (ft)" />
        </div>
        <div class="field">
          <label for="species">Species / grade (optional)</label>
          <input id="species" type="text" placeholder="e.g. DF No. 2" />
        </div>
        <div class="field">
          <label for="designMethod">Design method</label>
          <select id="designMethod">
            <option value="ASD">ASD</option>
            <option value="LRFD">LRFD</option>
          </select>
        </div>
      </div>
    </section>

    <!-- 2: LOADS -->
    <section class="card">
      <h2>2. Loads on the beam</h2>
      <p class="sub">
        Simple span with optional uniform load over a segment and an optional point load. All loads are
        assumed downward.
      </p>

      <h3>2A. Segment uniform load</h3>
      <div class="grid">
        <div class="field">
          <label for="wUniform">Uniform load, w (force / length)</label>
          <input id="wUniform" type="number" step="0.01" placeholder="e.g. 0.8 (k/ft or kip/ft)" />
        </div>
        <div class="field">
          <label for="wStart">Uniform load start, a (from left support)</label>
          <input id="wStart" type="number" step="0.01" placeholder="e.g. 0" />
        </div>
        <div class="field">
          <label for="wEnd">Uniform load end, b (from left support)</label>
          <input id="wEnd" type="number" step="0.01" placeholder="e.g. 16" />
        </div>
      </div>
      <p class="sub" style="margin-top:0.4rem;">
        Tip: full-length load = set <em>a = 0</em> and <em>b = L</em>. Leave w = 0 to ignore the uniform load.
      </p>

      <h3>2B. Point load</h3>
      <div class="grid">
        <div class="field">
          <label for="Ppoint">Point load, P (force)</label>
          <input id="Ppoint" type="number" step="0.01" placeholder="e.g. 5 (kips)" />
        </div>
        <div class="field">
          <label for="Px">Point load location, x<sub>P</sub> (from left)</label>
          <input id="Px" type="number" step="0.01" placeholder="e.g. 8" />
        </div>
      </div>

      <p class="sub" style="margin-top:0.4rem;">
        All loads are treated as downward. The beam is simply supported at x = 0 and x = L.
      </p>
    </section>

    <!-- 3: EQUATION CHOICES -->
    <section class="card">
      <h2>3. Pick the internal force equations</h2>
      <p class="sub">
        Before the beam will give you numbers, you have to pick the correct equations for the uniform load.
        We’ll only look at the <em>uniform load part</em> here and call the local coordinate from the start of
        that load <code>z</code>.
      </p>

      <div class="eq-block">
        <h3>3A. Bending moment from the uniform load</h3>
        <p>
          For a uniform load of intensity <code>w</code> acting over a segment of length
          <code>L<sub>u</sub></code>, measured from its start as <code>z = x − a</code>, what is the
          internal bending moment from <em>that uniform load alone</em> for <code>0 ≤ z ≤ L<sub>u</sub></code>?
        </p>
        <div class="eq-options">
          <label>
            <input type="radio" name="momentEq" id="momentCorrect" />
            <span>
              <code>M<sub>w</sub>(z) = w·z² / 2</code> &nbsp;– uses distance measured from the start of the load.
            </span>
          </label>
          <label>
            <input type="radio" name="momentEq" id="momentWrong" />
            <span>
              <code>M<sub>w</sub>(z) = w·x² / 2</code> &nbsp;– treats the load as if it always starts at the
              left support.
            </span>
          </label>
        </div>
        <div class="button-row" style="margin-top:0.6rem;">
          <button class="secondary" type="button" id="btnCheckMoment">Check moment equation</button>
        </div>
      </div>

      <div class="eq-block">
        <h3>3B. Shear from the uniform load</h3>
        <p>
          For that same uniform load, again using <code>z</code> measured from the start of the load, what is
          the internal shear from the uniform load alone?
        </p>
        <div class="eq-options">
          <label>
            <input type="radio" name="shearEq" id="shearCorrect" />
            <span>
              <code>V<sub>w</sub>(z) = w·z</code> &nbsp;– starts at zero at the beginning of the load.
            </span>
          </label>
          <label>
            <input type="radio" name="shearEq" id="shearWrong" />
            <span>
              <code>V<sub>w</sub>(z) = w·x</code> &nbsp;– again pretending the load starts at the support.
            </span>
          </label>
        </div>
        <div class="button-row" style="margin-top:0.6rem;">
          <button class="secondary" type="button" id="btnCheckShear">Check shear equation</button>
        </div>
      </div>

      <div id="equationStatus" class="copy-status" aria-live="polite"></div>

      <div class="button-row">
        <button class="primary" type="button" id="btnCompute">
          ✅ Compute reactions, V-max, M-max & mini-report
        </button>
      </div>
    </section>

    <!-- 4: RESULTS -->
    <section class="card">
      <h2>4. Results & mini-report</h2>
      <p class="sub">
        Numeric results based on your loads, plus the (slightly nerdy) formulas used under the hood.
      </p>
      <pre id="resultsOutput" class="mono-block"></pre>

      <h3>Formulas used (symbolic)</h3>
      <pre id="formulaOutput" class="mono-block small"></pre>
    </section>

    <footer>
      Wood Beams Trainer – simple span with w(a→b) + P at x<sub>P</sub>. Check your math, not just the answers.
    </footer>
  </div>

  <script>
    (function () {
      let momentOk = false;
      let shearOk = false;

      function num(id) {
        var v = parseFloat(document.getElementById(id).value);
        return isNaN(v) ? null : v;
      }

      function str(id) {
        return (document.getElementById(id).value || "").trim();
      }

      function fmt(x, digits) {
        if (x === null || x === undefined || isNaN(x)) return "N/A";
        return x.toFixed(digits != null ? digits : 3);
      }

      /**
       * Compute reactions and envelopes for:
       * - simple span beam length L
       * - uniform load w from a to b (downward)
       * - point load P at xP (downward)
       */
      function computeBeam(L, w, a, b, P, xP) {
        const hasUniform = w !== null && Math.abs(w) > 0 && a !== null && b !== null && b > a;
        const hasPoint = P !== null && Math.abs(P) > 0 && xP !== null;

        const Lload = hasUniform ? (b - a) : 0;
        const W = hasUniform ? w * Lload : 0;
        const xc = hasUniform ? (a + b) / 2 : 0;

        const totalLoad = (hasUniform ? W : 0) + (hasPoint ? P : 0);

        let RB = 0;
        if (L > 0) {
          const momentLoads = (hasUniform ? W * xc : 0) + (hasPoint ? P * xP : 0);
          RB = momentLoads / L;
        }
        const RA = totalLoad - RB;

        function seg(x) {
          if (!hasUniform) return 0;
          return Math.max(0, Math.min(x, b) - a);
        }

        function shear(x) {
          let V = RA;
          if (hasUniform) {
            V -= w * seg(x);
          }
          if (hasPoint && x >= xP) {
            V -= P;
          }
          return V;
        }

        function uniformMoment(x) {
          if (!hasUniform) return 0;
          const segLen = seg(x);
          if (segLen <= 0) return 0;

          let xCenter;
          if (x < b) {
            // centroid of segment [a, x]
            xCenter = (a + x) / 2;
          } else {
            // full loaded length, centroid at mid of [a, b]
            xCenter = xc;
          }
          const Wseg = w * segLen;
          return Wseg * (x - xCenter);
        }

        function moment(x) {
          let M = RA * x;
          if (hasUniform) {
            M -= uniformMoment(x);
          }
          if (hasPoint && x >= xP) {
            M -= P * (x - xP);
          }
          return M;
        }

        const steps = 400;
        let Vmax = -Infinity, Vmin = Infinity;
        let xVmax = 0, xVmin = 0;
        let Mmax = -Infinity, Mmin = Infinity;
        let xMmax = 0, xMmin = 0;

        for (let i = 0; i <= steps; i++) {
          const x = (L * i) / steps;
          const Vx = shear(x);
          const Mx = moment(x);

          if (Vx > Vmax) { Vmax = Vx; xVmax = x; }
          if (Vx < Vmin) { Vmin = Vx; xVmin = x; }

          if (Mx > Mmax) { Mmax = Mx; xMmax = x; }
          if (Mx < Mmin) { Mmin = Mx; xMmin = x; }
        }

        return {
          L, w, a, b, P, xP,
          hasUniform,
          hasPoint,
          Lload,
          W,
          xc,
          RA,
          RB,
          Vmax,
          Vmin,
          xVmax,
          xVmin,
          Mmax,
          Mmin,
          xMmax,
          xMmin
        };
      }

      function showStatus(message, type) {
        var status = document.getElementById("equationStatus");
        status.textContent = message || "";
        status.className = "copy-status" + (type ? " " + type : "");
      }

      function handleCheckMoment() {
        var choice = document.querySelector('input[name="momentEq"]:checked');
        if (!choice) {
          showStatus("Pick one of the moment options first – the beam can’t read your mind (yet).", "error");
          return;
        }

        if (choice.id === "momentCorrect") {
          momentOk = true;
          showStatus("Nice – using M_w(z) = w·z² / 2 keeps the origin at the start of the load.", "success");
        } else {
          momentOk = false;
          showStatus("That one treats the load like it always starts at x = 0. The beam is quietly judging you. Try again.", "error");
        }
      }

      function handleCheckShear() {
        var choice = document.querySelector('input[name=\"shearEq\"]:checked');
        if (!choice) {
          showStatus("Pick one of the shear options – no partial credit for vibes.", "error");
          return;
        }

        if (choice.id === "shearCorrect") {
          shearOk = true;
          showStatus("Correct – V_w(z) = w·z grows linearly from the start of the loaded segment.", "success");
        } else {
          shearOk = false;
          showStatus("That shear equation thinks the load begins at the left support. The load strongly disagrees. Try again.", "error");
        }
      }

      function computeAndDisplay() {
        if (!momentOk || !shearOk) {
          showStatus("My ethics subroutine refuses to compute design forces until you pick the right moment AND shear equations.", "error");
          return;
        }

        var L = num("L");
        var w = num("wUniform") || 0;
        var a = num("wStart") || 0;
        var b = num("wEnd") || 0;
        var P = num("Ppoint") || 0;
        var xP = num("Px");

        var designMethod = str("designMethod") || "ASD";
        var species = str("species");

        if (L === null || L <= 0) {
          showStatus("Span length L needs to be a positive number. Right now it’s not.", "error");
          return;
        }

        if (b < a) {
          showStatus("For the uniform load, end b must be ≥ start a. Unless you’ve invented negative length, flip those.", "error");
          return;
        }

        if ((P !== 0) && (xP === null || xP < 0 || xP > L)) {
          showStatus("Point load location x_P must be between 0 and L when P ≠ 0.", "error");
          return;
        }

        var result = computeBeam(L, w, a, b, P, xP);

        var lines = [];
        lines.push("WOOD BEAM SUMMARY – SIMPLE SPAN");
        lines.push("--------------------------------");
        lines.push("Design method: " + designMethod);
        if (species) lines.push("Species / grade: " + species);
        lines.push("");
        lines.push("Span length: L = " + fmt(result.L, 3));
        lines.push("");

        if (result.hasUniform) {
          lines.push("Uniform load segment:");
          lines.push("  w = " + fmt(result.w, 3) + " (force / length units)");
          lines.push("  start a = " + fmt(result.a, 3));
          lines.push("  end   b = " + fmt(result.b, 3));
          lines.push("  loaded length L_u = b − a = " + fmt(result.Lload, 3));
          lines.push("  resultant W = w · L_u = " + fmt(result.W, 3));
          lines.push("  resultant acts at x_c = (a + b) / 2 = " + fmt(result.xc, 3));
          lines.push("");
        } else {
          lines.push("Uniform load: none (w = 0 or b ≤ a).");
          lines.push("");
        }

        if (result.hasPoint) {
          lines.push("Point load:");
          lines.push("  P = " + fmt(result.P, 3));
          lines.push("  x_P = " + fmt(result.xP, 3));
          lines.push("");
        } else {
          lines.push("Point load: none (P = 0).");
          lines.push("");
        }

        lines.push("Reactions (upward positive):");
        lines.push("  R_A = " + fmt(result.RA, 3));
        lines.push("  R_B = " + fmt(result.RB, 3));
        lines.push("");

        lines.push("Shear envelope (upward positive):");
        lines.push("  V_max (most positive) = " + fmt(result.Vmax, 3) +
          " at x ≈ " + fmt(result.xVmax, 3));
        lines.push("  V_min (most negative) = " + fmt(result.Vmin, 3) +
          " at x ≈ " + fmt(result.xVmin, 3));
        lines.push("");

        lines.push("Moment envelope (sagging positive by sign convention):");
        lines.push("  M_max (most positive) = " + fmt(result.Mmax, 3) +
          " at x ≈ " + fmt(result.xMmax, 3));
        lines.push("  M_min (most negative) = " + fmt(result.Mmin, 3) +
          " at x ≈ " + fmt(result.xMmin, 3));
        lines.push("");
        lines.push("Remember to convert these to the appropriate design values for " + designMethod + ".");
        lines.push("");

        document.getElementById("resultsOutput").textContent = lines.join("\n");

        // Formulas used – symbolic, showing the load locations
        var f = [];
        f.push("ASSUMPTIONS");
        f.push("-----------");
        f.push("Simple span beam with supports at x = 0 and x = L.");
        f.push("Uniform load w on segment [a, b] (downward).");
        f.push("Point load P at x = x_P (downward).");
        f.push("");
        f.push("RESULTANT OF UNIFORM LOAD");
        f.push("  L_u = b − a");
        f.push("  W   = w · L_u");
        f.push("  x_c = (a + b) / 2   (centroid of uniform segment)");
        f.push("");
        f.push("REACTIONS (from ΣM_A = 0 and ΣV = 0):");
        f.push("  R_B = ( W · x_c + P · x_P ) / L");
        f.push("  R_A = W + P − R_B");
        f.push("");
        f.push("SHEAR (upward positive):");
        f.push("  Let L_u(x) = max(0, min(x, b) − a) be the length of loaded segment to the left of x.");
        f.push("  Let H(x − x_P) be the Heaviside step function (0 for x < x_P, 1 for x ≥ x_P).");
        f.push("");
        f.push("  V(x) = R_A − w · L_u(x) − P · H(x − x_P)");
        f.push("");
        f.push("MOMENT (sagging positive):");
        f.push("  Contribution from R_A:       M_RA(x) = R_A · x");
        f.push("  Contribution from uniform w: M_w(x)  ≈ W_x · (x − x_c(x)), where");
        f.push("    W_x   = w · L_u(x)");
        f.push("    x_c(x) =");
        f.push("      (a + x)/2   for a < x < b  (centroid of the partial segment [a, x])");
        f.push("      (a + b)/2   for x ≥ b      (full segment [a, b])");
        f.push("");
        f.push("  Contribution from point P:   M_P(x) = P · max(0, x − x_P)");
        f.push("");
        f.push("  Total moment:");
        f.push("    M(x) = M_RA(x) − M_w(x) − M_P(x)");
        f.push("");
        f.push("LOCAL COORDINATE INSIDE THE UNIFORM LOAD (USED IN THE QUIZ):");
        f.push("  Let z = x − a,  0 ≤ z ≤ L_u.");
        f.push("  Then the contribution of the uniform load alone can be written as:");
        f.push("    V_w(z) = w · z");
        f.push("    M_w(z) = w · z² / 2");
        f.push("  which is why the beam got so offended when you tried to use x instead of z.");

        document.getElementById("formulaOutput").textContent = f.join("\n");

        showStatus("Math accepted. Results and formulas updated below.", "success");
      }

      document.getElementById("btnCheckMoment").addEventListener("click", handleCheckMoment);
      document.getElementById("btnCheckShear").addEventListener("click", handleCheckShear);
      document.getElementById("btnCompute").addEventListener("click", computeAndDisplay);
    })();
  </script>
</body>
</html>
